/**
 * Returns whether the given error object is an AbortError (generated by an AbortSignal aborting).
 */
export function isAbortError(err: any): err is AbortError {
  return err instanceof Error && err.name === 'AbortError'
}

class AbortError extends Error {
  constructor(cause?: unknown) {
    super('Aborted', cause !== undefined ? { cause } : undefined)
    this.name = 'AbortError'
  }
}

/**
 * Races a given Promise against an `AbortSignal` becoming aborted, returning a Promise that will
 * either resolve/reject with the resolution of the Promise, or an `AbortError`, whichever happens
 * first.
 *
 * @see Promise.race
 */
// Implementation mostly from:
// https://github.com/whatwg/dom/issues/946#issuecomment-845906896
export async function raceAbort<T>(signal: AbortSignal, promise: Promise<T>): Promise<T> {
  if (signal.aborted) throw new AbortError(signal.reason)

  let onAbort: () => void | undefined
  return Promise.race([
    promise,
    new Promise<T>((_, reject) => {
      onAbort = () => reject(new AbortError(signal.reason))
      signal.addEventListener('abort', onAbort)
    }),
  ]).finally(() => signal.removeEventListener('abort', onAbort))
}
