/**
 * Returns whether the given error object is an AbortError (generated by an AbortSignal aborting).
 */
export function isAbortError(err: any): err is AbortError {
  return err instanceof Error && err.name === 'AbortError'
}

class AbortError extends Error {
  constructor(cause?: unknown) {
    super('Aborted', cause !== undefined ? { cause } : undefined)
    this.name = 'AbortError'
  }
}

/**
 * Races a given Promise against an `AbortSignal` becoming aborted, returning a Promise that will
 * either resolve/reject with the resolution of the Promise, or an `AbortError`, whichever happens
 * first.
 *
 * @see Promise.race
 */
// Implementation mostly from:
// https://github.com/whatwg/dom/issues/946#issuecomment-845906896
export async function raceAbort<T>(signal: AbortSignal, promise: Promise<T>): Promise<T> {
  if (signal.aborted) throw new AbortError(signal.reason)

  let onAbort: () => void | undefined
  return Promise.race([
    promise,
    new Promise<T>((_, reject) => {
      onAbort = () => reject(new AbortError(signal.reason))
      signal.addEventListener('abort', onAbort)
    }),
  ]).finally(() => signal.removeEventListener('abort', onAbort))
}

/**
 * Combines 2 or more `AbortSignal`s into a single one, such that any of them being aborted will
 * abort the combined signal.
 *
 * The signal will be aborted with the `reason` of the first signal to abort.
 */
export function combinedAbortSignal(signals: Iterable<AbortSignal>): AbortSignal {
  // Before we do any work, check if any of the signals are already aborted
  for (const signal of signals) {
    if (signal.aborted) {
      // NOTE(tec27): TS types don't seem to have `AbortSignal.abort()` yet, can be simplified once
      // they do
      const controller = new AbortController()
      controller.abort(signal.reason)
      return controller.signal
    }
  }

  const controller = new AbortController()
  const localSignals = new Map(
    Array.from(signals, s => [
      s,
      () => {
        controller.abort(s.reason)
        for (const [signal, listener] of localSignals) {
          signal.removeEventListener('abort', listener)
        }
      },
    ]),
  )

  for (const [signal, listener] of localSignals.entries()) {
    signal.addEventListener('abort', listener)
  }

  return controller.signal
}
